var j=Object.defineProperty;var z=(s,t,e)=>t in s?j(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var _=(s,t,e)=>z(s,typeof t!="symbol"?t+"":t,e);import{r as A,g as F,R as J}from"./index-B9z3Nz-g.js";const M={},D=s=>{let t;const e=new Set,r=(v,p)=>{const S=typeof v=="function"?v(t):v;if(!Object.is(S,t)){const l=t;t=p??(typeof S!="object"||S===null)?S:Object.assign({},t,S),e.forEach(m=>m(t,l))}},o=()=>t,f={setState:r,getState:o,getInitialState:()=>d,subscribe:v=>(e.add(v),()=>e.delete(v)),destroy:()=>{(M?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),e.clear()}},d=t=s(r,o,f);return f},q=s=>s?D(s):D;var C={exports:{}},T={},U={exports:{}},P={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var w=A;function B(s,t){return s===t&&(s!==0||1/s===1/t)||s!==s&&t!==t}var G=typeof Object.is=="function"?Object.is:B,X=w.useState,K=w.useEffect,Q=w.useLayoutEffect,Y=w.useDebugValue;function Z(s,t){var e=t(),r=X({inst:{value:e,getSnapshot:t}}),o=r[0].inst,n=r[1];return Q(function(){o.value=e,o.getSnapshot=t,k(o)&&n({inst:o})},[s,e,t]),K(function(){return k(o)&&n({inst:o}),s(function(){k(o)&&n({inst:o})})},[s]),Y(e),e}function k(s){var t=s.getSnapshot;s=s.value;try{var e=t();return!G(s,e)}catch{return!0}}function V(s,t){return t()}var ee=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?V:Z;P.useSyncExternalStore=w.useSyncExternalStore!==void 0?w.useSyncExternalStore:ee;U.exports=P;var te=U.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var I=A,re=te;function se(s,t){return s===t&&(s!==0||1/s===1/t)||s!==s&&t!==t}var ne=typeof Object.is=="function"?Object.is:se,oe=re.useSyncExternalStore,ae=I.useRef,ie=I.useEffect,ce=I.useMemo,ue=I.useDebugValue;T.useSyncExternalStoreWithSelector=function(s,t,e,r,o){var n=ae(null);if(n.current===null){var u={hasValue:!1,value:null};n.current=u}else u=n.current;n=ce(function(){function f(l){if(!d){if(d=!0,v=l,l=r(l),o!==void 0&&u.hasValue){var m=u.value;if(o(m,l))return p=m}return p=l}if(m=p,ne(v,l))return m;var c=r(l);return o!==void 0&&o(m,c)?(v=l,m):(v=l,p=c)}var d=!1,v,p,S=e===void 0?null:e;return[function(){return f(t())},S===null?void 0:function(){return f(S())}]},[t,e,r,o]);var h=oe(s,n[0],n[1]);return ie(function(){u.hasValue=!0,u.value=h},[h]),ue(h),h};C.exports=T;var de=C.exports;const le=F(de),L={},{useDebugValue:he}=J,{useSyncExternalStoreWithSelector:fe}=le;let R=!1;const ve=s=>s;function pe(s,t=ve,e){(L?"production":void 0)!=="production"&&e&&!R&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),R=!0);const r=fe(s.subscribe,s.getState,s.getServerState||s.getInitialState,t,e);return he(r),r}const O=s=>{(L?"production":void 0)!=="production"&&typeof s!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const t=typeof s=="function"?q(s):s,e=(r,o)=>pe(t,r,o);return Object.assign(e,t),e},me=s=>s?O(s):O,Se={},ge=s=>(t,e,r)=>{const o=r.subscribe;return r.subscribe=(u,h,f)=>{let d=u;if(h){const v=(f==null?void 0:f.equalityFn)||Object.is;let p=u(r.getState());d=S=>{const l=u(S);if(!v(p,l)){const m=p;h(p=l,m)}},f!=null&&f.fireImmediately&&h(p,p)}return o(d)},s(t,e,r)},ye=ge;function W(s,t){let e;try{e=s()}catch{return}return{getItem:o=>{var n;const u=f=>f===null?null:JSON.parse(f,void 0),h=(n=e.getItem(o))!=null?n:null;return h instanceof Promise?h.then(u):u(h)},setItem:(o,n)=>e.setItem(o,JSON.stringify(n,void 0)),removeItem:o=>e.removeItem(o)}}const E=s=>t=>{try{const e=s(t);return e instanceof Promise?e:{then(r){return E(r)(e)},catch(r){return this}}}catch(e){return{then(r){return this},catch(r){return E(r)(e)}}}},be=(s,t)=>(e,r,o)=>{let n={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:i=>i,version:0,merge:(i,g)=>({...g,...i}),...t},u=!1;const h=new Set,f=new Set;let d;try{d=n.getStorage()}catch{}if(!d)return s((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${n.name}', the given storage is currently unavailable.`),e(...i)},r,o);const v=E(n.serialize),p=()=>{const i=n.partialize({...r()});let g;const a=v({state:i,version:n.version}).then(b=>d.setItem(n.name,b)).catch(b=>{g=b});if(g)throw g;return a},S=o.setState;o.setState=(i,g)=>{S(i,g),p()};const l=s((...i)=>{e(...i),p()},r,o);let m;const c=()=>{var i;if(!d)return;u=!1,h.forEach(a=>a(r()));const g=((i=n.onRehydrateStorage)==null?void 0:i.call(n,r()))||void 0;return E(d.getItem.bind(d))(n.name).then(a=>{if(a)return n.deserialize(a)}).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==n.version){if(n.migrate)return n.migrate(a.state,a.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return a.state}).then(a=>{var b;return m=n.merge(a,(b=r())!=null?b:l),e(m,!0),p()}).then(()=>{g==null||g(m,void 0),u=!0,f.forEach(a=>a(m))}).catch(a=>{g==null||g(void 0,a)})};return o.persist={setOptions:i=>{n={...n,...i},i.getStorage&&(d=i.getStorage())},clearStorage:()=>{d==null||d.removeItem(n.name)},getOptions:()=>n,rehydrate:()=>c(),hasHydrated:()=>u,onHydrate:i=>(h.add(i),()=>{h.delete(i)}),onFinishHydration:i=>(f.add(i),()=>{f.delete(i)})},c(),m||l},_e=(s,t)=>(e,r,o)=>{let n={storage:W(()=>localStorage),partialize:c=>c,version:0,merge:(c,i)=>({...i,...c}),...t},u=!1;const h=new Set,f=new Set;let d=n.storage;if(!d)return s((...c)=>{console.warn(`[zustand persist middleware] Unable to update item '${n.name}', the given storage is currently unavailable.`),e(...c)},r,o);const v=()=>{const c=n.partialize({...r()});return d.setItem(n.name,{state:c,version:n.version})},p=o.setState;o.setState=(c,i)=>{p(c,i),v()};const S=s((...c)=>{e(...c),v()},r,o);o.getInitialState=()=>S;let l;const m=()=>{var c,i;if(!d)return;u=!1,h.forEach(a=>{var b;return a((b=r())!=null?b:S)});const g=((i=n.onRehydrateStorage)==null?void 0:i.call(n,(c=r())!=null?c:S))||void 0;return E(d.getItem.bind(d))(n.name).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==n.version){if(n.migrate)return[!0,n.migrate(a.state,a.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,a.state];return[!1,void 0]}).then(a=>{var b;const[N,x]=a;if(l=n.merge(x,(b=r())!=null?b:S),e(l,!0),N)return v()}).then(()=>{g==null||g(l,void 0),l=r(),u=!0,f.forEach(a=>a(l))}).catch(a=>{g==null||g(void 0,a)})};return o.persist={setOptions:c=>{n={...n,...c},c.storage&&(d=c.storage)},clearStorage:()=>{d==null||d.removeItem(n.name)},getOptions:()=>n,rehydrate:()=>m(),hasHydrated:()=>u,onHydrate:c=>(h.add(c),()=>{h.delete(c)}),onFinishHydration:c=>(f.add(c),()=>{f.delete(c)})},n.skipHydration||m(),l||S},we=(s,t)=>"getStorage"in t||"serialize"in t||"deserialize"in t?((Se?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),be(s,t)):_e(s,t),Ee=we,y=me()(ye(Ee((s,t)=>({products:[],customers:[],orders:[],drivers:[],activeDeliveries:[],notifications:[],isLoading:!1,error:null,lastUpdated:null,connectionStatus:"disconnected",user:null,setProducts:e=>s({products:e}),addProduct:e=>s(r=>({products:[...r.products,e]})),updateProduct:(e,r)=>s(o=>({products:o.products.map(n=>n.id===e?{...n,...r}:n)})),deleteProduct:e=>s(r=>({products:r.products.filter(o=>o.id!==e)})),setCustomers:e=>s({customers:e}),addCustomer:e=>s(r=>({customers:[...r.customers,e]})),updateCustomer:(e,r)=>s(o=>({customers:o.customers.map(n=>n.id===e?{...n,...r}:n)})),setOrders:e=>s({orders:e}),addOrder:e=>s(r=>({orders:[e,...r.orders]})),updateOrder:(e,r)=>s(o=>({orders:o.orders.map(n=>n.id===e?{...n,...r}:n)})),updateOrderStatus:(e,r)=>s(o=>({orders:o.orders.map(n=>n.orderId===e?{...n,status:r}:n)})),setDrivers:e=>s({drivers:e}),addDriver:e=>s(r=>({drivers:[...r.drivers,e]})),updateDriver:(e,r)=>s(o=>({drivers:o.drivers.map(n=>n.id===e?{...n,...r}:n)})),setActiveDeliveries:e=>s({activeDeliveries:e}),updateDeliveryProgress:(e,r)=>s(o=>({activeDeliveries:o.activeDeliveries.map(n=>n.orderId===e?{...n,progress:r}:n)})),updateDeliveryStatus:(e,r)=>s(o=>({activeDeliveries:o.activeDeliveries.map(n=>n.orderId===e?{...n,status:r}:n)})),assignDriver:(e,r)=>s(o=>({orders:o.orders.map(n=>n.orderId===e?{...n,driver:`Driver ${r}`,status:"assigned"}:n)})),addNotification:e=>s(r=>({notifications:[{...e,id:`notif_${Date.now()}_${Math.random()}`,timestamp:new Date,isRead:!1},...r.notifications]})),markAsRead:e=>s(r=>({notifications:r.notifications.map(o=>o.id===e?{...o,isRead:!0}:o)})),clearNotifications:()=>s({notifications:[]}),setLoading:e=>s({isLoading:e}),setError:e=>s({error:e}),setConnectionStatus:e=>s({connectionStatus:e}),updateLastUpdated:()=>s({lastUpdated:new Date}),setUser:e=>s({user:e}),updateProfile:e=>s(r=>({user:r.user?{...r.user,...e}:null})),logout:()=>s({user:null,orders:[],notifications:[]})}),{name:"cannabis-delivery-store",storage:W(()=>localStorage),partialize:s=>({user:s.user,connectionStatus:s.connectionStatus})})));var H={};const Ie=H.NEXT_PUBLIC_API_URL||"http://localhost:3001/api",$=H.NEXT_PUBLIC_WS_URL||"ws://localhost:3001";class ke{constructor(t){_(this,"baseUrl");_(this,"token",null);this.baseUrl=t}setToken(t){this.token=t}async request(t,e={}){const r=`${this.baseUrl}${t}`,o={"Content-Type":"application/json",...e.headers};this.token&&(o.Authorization=`Bearer ${this.token}`);try{const n=await fetch(r,{...e,headers:o}),u=await n.json();return n.ok?{success:!0,data:u.data||u,message:u.message}:{success:!1,error:u.message||`HTTP ${n.status}`}}catch(n){return{success:!1,error:n instanceof Error?n.message:"Network error"}}}async get(t){return this.request(t,{method:"GET"})}async post(t,e){return this.request(t,{method:"POST",body:e?JSON.stringify(e):void 0})}async put(t,e){return this.request(t,{method:"PUT",body:e?JSON.stringify(e):void 0})}async delete(t){return this.request(t,{method:"DELETE"})}async patch(t,e){return this.request(t,{method:"PATCH",body:e?JSON.stringify(e):void 0})}}class De{constructor(){_(this,"client");this.client=new ke(Ie)}initialize(t){t&&this.client.setToken(t)}async login(t,e){const r=await this.client.post("/auth/login",{email:t,password:e});return r.success&&r.data&&(this.client.setToken(r.data.token),y.getState().setUser({...r.data.user,isAuthenticated:!0,token:r.data.token})),r}async register(t){const e=await this.client.post("/auth/register",t);return e.success&&e.data&&(this.client.setToken(e.data.token),y.getState().setUser({...e.data.user,isAuthenticated:!0,token:e.data.token})),e}async logout(){await this.client.post("/auth/logout"),this.client.setToken(""),y.getState().logout()}async refreshToken(){const t=await this.client.post("/auth/refresh");return t.success&&t.data&&(this.client.setToken(t.data.token),y.getState().updateProfile({token:t.data.token})),t}async createOrder(t){const e=await this.client.post("/orders",t);return e.success&&e.data&&y.getState().addOrder(e.data),e}async getOrders(){const t=await this.client.get("/orders");return t.success&&t.data&&y.getState().setOrders(t.data),t}}class Re{constructor(){_(this,"ws",null);_(this,"reconnectAttempts",0);_(this,"maxReconnectAttempts",5);_(this,"reconnectDelay",1e3);_(this,"heartbeatInterval",null);_(this,"eventListeners",new Map)}connect(t){try{const e=t?`${$}?token=${encodeURIComponent(t)}`:$;this.ws=new WebSocket(e),this.ws.onopen=()=>{console.log("ðŸ”Œ WebSocket connected"),this.reconnectAttempts=0,y.getState().setConnectionStatus("connected"),this.startHeartbeat(),t&&this.send({type:"auth",token:t})},this.ws.onmessage=r=>{try{const o=JSON.parse(r.data);this.handleMessage(o)}catch(o){console.error("Failed to parse WebSocket message:",o)}},this.ws.onclose=()=>{console.log("ðŸ”Œ WebSocket disconnected"),this.stopHeartbeat(),y.getState().setConnectionStatus("disconnected"),this.attemptReconnect()},this.ws.onerror=r=>{console.error("ðŸ”Œ WebSocket error:",r),y.getState().setConnectionStatus("disconnected")}}catch(e){console.error("Failed to connect WebSocket:",e),y.getState().setConnectionStatus("disconnected")}}disconnect(){this.stopHeartbeat(),this.ws&&(this.ws.close(),this.ws=null)}send(t){this.ws&&this.ws.readyState===WebSocket.OPEN?this.ws.send(JSON.stringify(t)):console.warn("WebSocket not connected, message not sent:",t)}on(t,e){this.eventListeners.has(t)||this.eventListeners.set(t,[]),this.eventListeners.get(t).push(e)}off(t,e){const r=this.eventListeners.get(t);if(r){const o=r.indexOf(e);o>-1&&r.splice(o,1)}}emit(t,e){const r=this.eventListeners.get(t);r&&r.forEach(o=>{try{o(e)}catch(n){console.error(`Error in event listener for ${t}:`,n)}})}handleMessage(t){const e=y.getState();switch(t.type){case"order_update":e.updateOrder(t.data.id,t.data),e.addNotification({type:"order",title:"Order Updated",message:`Order ${t.data.orderId} status changed to ${t.data.status}`,priority:"medium",orderId:t.data.orderId}),this.emit("order_update",t.data);break;case"order_placed":this.emit("order_placed",t.data);break;case"driver_accept_order":this.emit("driver_accept_order",t.data);break;case"order_status_update":this.emit("order_status_update",t.data);break;case"driver_location_update":this.emit("driver_location_update",t.data);break;case"notification":e.addNotification(t.data),this.emit("notification",t.data);break;case"heartbeat":this.send({type:"heartbeat_ack"});break;default:console.log("Unknown WebSocket message type:",t.type)}}attemptReconnect(){if(this.reconnectAttempts<this.maxReconnectAttempts){this.reconnectAttempts++;const t=y.getState();t.setConnectionStatus("reconnecting"),setTimeout(()=>{console.log(`ðŸ”Œ Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);const e=t.user;this.connect((e==null?void 0:e.token)||(e==null?void 0:e.email))},this.reconnectDelay*this.reconnectAttempts)}else console.log("ðŸ”Œ Max reconnection attempts reached"),y.getState().setConnectionStatus("disconnected")}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.send({type:"heartbeat"})},3e4)}stopHeartbeat(){this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null)}}const Oe=new De,$e=new Re,Te={apiService:Oe,wsService:$e};export{De as CannabisDeliveryApi,Re as WebSocketService,Oe as apiService,Te as default,$e as wsService};
//# sourceMappingURL=api-integration-service-BcIiEZNv.js.map
